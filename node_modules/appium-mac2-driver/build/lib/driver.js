"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mac2Driver = void 0;
const lodash_1 = __importDefault(require("lodash"));
const driver_1 = require("appium/driver");
const wda_mac_1 = require("./wda-mac");
const constraints_1 = __importDefault(require("./constraints"));
const appManagemenetCommands = __importStar(require("./commands/app-management"));
const appleScriptCommands = __importStar(require("./commands/applescript"));
const executeCommands = __importStar(require("./commands/execute"));
const findCommands = __importStar(require("./commands/find"));
const gesturesCommands = __importStar(require("./commands/gestures"));
const navigationCommands = __importStar(require("./commands/navigation"));
const recordScreenCommands = __importStar(require("./commands/record-screen"));
const screenshotCommands = __importStar(require("./commands/screenshots"));
const sourceCommands = __importStar(require("./commands/source"));
const clipboardCommands = __importStar(require("./commands/clipboard"));
const nativeScreenRecordingCommands = __importStar(require("./commands/native-record-screen"));
const logger_1 = __importDefault(require("./logger"));
const method_map_1 = require("./method-map");
const execute_method_map_1 = require("./execute-method-map");
const NO_PROXY = [
    ['GET', new RegExp('^/session/[^/]+/appium')],
    ['POST', new RegExp('^/session/[^/]+/appium')],
    ['POST', new RegExp('^/session/[^/]+/element/[^/]+/elements?$')],
    ['POST', new RegExp('^/session/[^/]+/elements?$')],
    ['POST', new RegExp('^/session/[^/]+/execute')],
    ['POST', new RegExp('^/session/[^/]+/execute/sync')],
    ['GET', new RegExp('^/session/[^/]+/timeouts$')],
    ['POST', new RegExp('^/session/[^/]+/timeouts$')],
];
class Mac2Driver extends driver_1.BaseDriver {
    isProxyActive;
    _wda;
    _videoChunksBroadcaster;
    _screenRecorder;
    proxyReqRes;
    static newMethodMap = method_map_1.newMethodMap;
    static executeMethodMap = execute_method_map_1.executeMethodMap;
    constructor(opts = {}) {
        super(opts);
        this.desiredCapConstraints = lodash_1.default.cloneDeep(constraints_1.default);
        this.locatorStrategies = [
            'id',
            'name',
            'accessibility id',
            'xpath',
            'class name',
            '-ios predicate string',
            'predicate string',
            '-ios class chain',
            'class chain',
        ];
        this.resetState();
        this.settings = new driver_1.DeviceSettings({}, this.onSettingsUpdate.bind(this));
    }
    async onSettingsUpdate(key, value) {
        if (!this._wda) {
            return;
        }
        return await this._wda.proxy.command('/appium/settings', 'POST', {
            settings: { [key]: value }
        });
    }
    get wda() {
        if (!this._wda) {
            throw new Error('WDA server is not initialized');
        }
        return this._wda;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    proxyActive(sessionId) {
        return this.isProxyActive;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getProxyAvoidList(sessionId) {
        return NO_PROXY;
    }
    canProxy() {
        return true;
    }
    async proxyCommand(url, method, body = null) {
        if (!this._wda) {
            throw new Error('WDA server is not initialized');
        }
        return await this._wda.proxy.command(url, method, body);
    }
    async getStatus() {
        if (!this._wda) {
            throw new Error('WDA server is not initialized');
        }
        return await this._wda.proxy.command('/status', 'GET');
    }
    // needed to make image plugin work
    async getWindowRect() {
        if (!this._wda) {
            throw new Error('WDA server is not initialized');
        }
        return await this._wda.proxy.command('/window/rect', 'GET');
    }
    async createSession(w3cCaps1, w3cCaps2, w3cCaps3, driverData) {
        const [sessionId, caps] = await super.createSession(w3cCaps1, w3cCaps2, w3cCaps3, driverData);
        this._wda = wda_mac_1.WDA_MAC_SERVER;
        this.caps = caps;
        this.opts = this.opts;
        try {
            const prerun = caps.prerun;
            if (prerun) {
                if (!lodash_1.default.isString(prerun.command) && !lodash_1.default.isString(prerun.script)) {
                    throw new Error(`'prerun' capability value must either contain ` +
                        `'script' or 'command' entry of string type`);
                }
                logger_1.default.info('Executing prerun AppleScript');
                const output = await this.macosExecAppleScript(prerun.script, undefined, prerun.command);
                if (lodash_1.default.trim(output)) {
                    logger_1.default.info(`Prerun script output: ${output}`);
                }
            }
            await this._wda.startSession(caps, {
                reqBasePath: this.basePath,
            });
        }
        catch (e) {
            await this.deleteSession();
            throw e;
        }
        this.proxyReqRes = this.wda.proxy.proxyReqRes.bind(this._wda.proxy);
        this.isProxyActive = true;
        return [sessionId, caps];
    }
    async deleteSession() {
        await this._screenRecorder?.stop(true);
        if (this._videoChunksBroadcaster.hasPublishers) {
            if (this._wda) {
                try {
                    await this.wda.proxy.command('/wda/video/stop', 'POST', {});
                }
                catch { }
            }
            await this._videoChunksBroadcaster.shutdown(5000);
        }
        if (this._wda) {
            await this.wda.stopSession();
        }
        const postrun = this.opts.postrun;
        if (postrun) {
            if (!lodash_1.default.isString(postrun.command) && !lodash_1.default.isString(postrun.script)) {
                logger_1.default.error(`'postrun' capability value must either contain ` +
                    `'script' or 'command' entry of string type`);
            }
            else {
                logger_1.default.info('Executing postrun AppleScript');
                try {
                    const output = await this.macosExecAppleScript(postrun.script, undefined, postrun.command);
                    if (lodash_1.default.trim(output)) {
                        logger_1.default.info(`Postrun script output: ${output}`);
                    }
                }
                catch (e) {
                    logger_1.default.error(e.message);
                }
            }
        }
        this.resetState();
        await super.deleteSession();
    }
    resetState() {
        this._wda = null;
        this.isProxyActive = false;
        this._videoChunksBroadcaster = new nativeScreenRecordingCommands.NativeVideoChunksBroadcaster(this.eventEmitter, this.log);
        this._screenRecorder = null;
    }
    macosLaunchApp = appManagemenetCommands.macosLaunchApp;
    macosActivateApp = appManagemenetCommands.macosActivateApp;
    macosTerminateApp = appManagemenetCommands.macosTerminateApp;
    macosQueryAppState = appManagemenetCommands.macosQueryAppState;
    macosExecAppleScript = appleScriptCommands.macosExecAppleScript;
    execute = executeCommands.execute;
    findElOrEls = findCommands.findElOrEls;
    macosSetValue = gesturesCommands.macosSetValue;
    macosClick = gesturesCommands.macosClick;
    macosScroll = gesturesCommands.macosScroll;
    macosSwipe = gesturesCommands.macosSwipe;
    macosRightClick = gesturesCommands.macosRightClick;
    macosHover = gesturesCommands.macosHover;
    macosDoubleClick = gesturesCommands.macosDoubleClick;
    macosClickAndDrag = gesturesCommands.macosClickAndDrag;
    macosClickAndDragAndHold = gesturesCommands.macosClickAndDragAndHold;
    macosKeys = gesturesCommands.macosKeys;
    macosPressAndHold = gesturesCommands.macosPressAndHold;
    macosTap = gesturesCommands.macosTap;
    macosDoubleTap = gesturesCommands.macosDoubleTap;
    macosPressAndDrag = gesturesCommands.macosPressAndDrag;
    macosPressAndDragAndHold = gesturesCommands.macosPressAndDragAndHold;
    macosGetClipboard = clipboardCommands.macosGetClipboard;
    macosSetClipboard = clipboardCommands.macosSetClipboard;
    macosDeepLink = navigationCommands.macosDeepLink;
    startRecordingScreen = recordScreenCommands.startRecordingScreen;
    stopRecordingScreen = recordScreenCommands.stopRecordingScreen;
    macosStartNativeScreenRecording = nativeScreenRecordingCommands.macosStartNativeScreenRecording;
    macosGetNativeScreenRecordingInfo = nativeScreenRecordingCommands.macosGetNativeScreenRecordingInfo;
    macosStopNativeScreenRecording = nativeScreenRecordingCommands.macosStopNativeScreenRecording;
    macosListDisplays = nativeScreenRecordingCommands.macosListDisplays;
    macosScreenshots = screenshotCommands.macosScreenshots;
    macosSource = sourceCommands.macosSource;
}
exports.Mac2Driver = Mac2Driver;
exports.default = Mac2Driver;
//# sourceMappingURL=driver.js.map